
/*
 * Creates the dynamic slot named [magic.slack.post].
 *
 * Arguments;
 * 
 * - `parent_ts` is optional and if specified it will post text as a reply to the existing thread
 * - `bot_token` is mandatory token required to interact with Slack.
 * - `channel` is mandatory channel name from Slack.
 * - `text` is mandatory text message to post to Slack channel.
 * - `external_id` is an optional value intended to allow for serializing the external id of the request, required to deal with replies in client code.
 */
slots.create:magic.slack.post

   // Sanity checking invocation.
   validators.mandatory:x:@.arguments/*/bot_token
   validators.regex:x:@.arguments/*/token
      regex:^xoxb-
   validators.mandatory:x:@.arguments/*/channel
   validators.string:x:@.arguments/*/channel
      min:5
      max:100
   validators.mandatory:x:@.arguments/*/text
   validators.string:x:@.arguments/*/text
      min:1

   // Creating our token.
   .token
   set-value:x:@.token
      strings.concat
         .:"Bearer "
         get-value:x:@.arguments/*/bot_token

   // Checking if [parent_ts] exists, at which point we're posting a reply.
   if
      and
         exists:x:@.arguments/*/parent_ts
         not-null:x:@.arguments/*/parent_ts
      .lambda
         add:x:../*/http.post/*/payload
            .
               thread_ts:x:@.arguments/*/parent_ts

   /*
    * Notice, to avoid race conditions where Slack invokes webhook before
    * we get to store the request in our database, we wrap the invocation in
    * a semaphore.
    */
   semaphore:slack.post

      // Invoking Slack.
      http.post:"https://slack.com/api/chat.postMessage"
         convert:true
         headers
            Authorization:x:@.token
            Content-Type:"application/json; charset=utf-8"
         payload
            channel:x:@.arguments/*/channel
            text:x:@.arguments/*/text
            mrkdwn:bool:true

      // Sanity checking result.
      if
         and
            mte:x:@http.post
               .:int:200
            lt:x:@http.post
               .:int:300
            not-exists:x:@http.post/*/content/*/error
            exists:x:@http.post/*/content/*/ts
         .lambda

            // Success, first storing request into database!
            data.connect:slack

               // Checking if we've got an external ID.
               if
                  and
                     exists:x:@.arguments/*/external_id
                     not-null:x:@.arguments/*/external_id
                  .lambda

                     // Making sure we insert external ID into database.
                     add:x:@data.connect/*/data.create/*/values
                        get-nodes:x:@.arguments/*/external_id

               // Inserting record into database.
               data.create
                  table:requests
                  values
                     ts:x:@http.post/*/content/*/ts
                     text:x:@.arguments/*/text

            // Then returning timestamp/ID to caller.
            yield
               ts:x:@http.post/*/content/*/ts

      // Failure
      throw:x:@http.post/*/content/*/error
         status:int:500
         public:bool:true

